name: Project Management

on:
  issues:
    types: [opened, closed, labeled, unlabeled, assigned]
  pull_request:
    types: [opened, closed, ready_for_review, converted_to_draft]
  schedule:
    # Run daily at 9 AM UTC for maintenance tasks
    - cron: "0 9 * * *"
  workflow_dispatch:

jobs:
  issue-triage:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'

    steps:
      - name: Auto-triage new issues
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body || '';
            const labels = [];

            // Priority assignment based on keywords
            if (title.includes('critical') || title.includes('urgent') || body.includes('production')) {
              labels.push('priority:critical');
            } else if (title.includes('security') || title.includes('vulnerability')) {
              labels.push('priority:high', 'security');
            } else if (title.includes('bug') || title.includes('error') || title.includes('broken')) {
              labels.push('priority:medium');
            } else {
              labels.push('priority:low');
            }

            // Complexity estimation
            const bodyLength = body.length;
            if (bodyLength > 1000 || title.includes('major') || title.includes('complex')) {
              labels.push('complexity:high');
            } else if (bodyLength > 500 || title.includes('moderate')) {
              labels.push('complexity:medium');
            } else {
              labels.push('complexity:low');
            }

            // Effort estimation for common issue types
            if (title.includes('template') && title.includes('add')) {
              labels.push('effort:medium', 'type:template');
            } else if (title.includes('documentation') || title.includes('docs')) {
              labels.push('effort:low', 'type:documentation');
            } else if (title.includes('feature')) {
              labels.push('effort:high', 'type:enhancement');
            }

            // Add good first issue label for simple tasks
            if (labels.includes('complexity:low') && 
                (title.includes('typo') || title.includes('documentation') || 
                 title.includes('example') || title.includes('readme'))) {
              labels.push('good first issue');
            }

            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            }

            // Create milestone assignment based on priority
            if (labels.includes('priority:critical') || labels.includes('priority:high')) {
              // Assign to current milestone (you'll need to create milestones)
              const milestones = await github.rest.issues.listMilestones({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open'
              });
              
              if (milestones.data.length > 0) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  milestone: milestones.data[0].number
                });
              }
            }

  roadmap-sync:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Update roadmap progress
        uses: actions/github-script@v7
        with:
          script: |
            // Get all issues and PRs
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100
            });

            // Categorize by milestone and status
            const milestoneProgress = {};

            for (const issue of issues.data) {
              if (issue.milestone) {
                const milestone = issue.milestone.title;
                if (!milestoneProgress[milestone]) {
                  milestoneProgress[milestone] = {
                    total: 0,
                    closed: 0,
                    open: 0
                  };
                }
                
                milestoneProgress[milestone].total++;
                if (issue.state === 'closed') {
                  milestoneProgress[milestone].closed++;
                } else {
                  milestoneProgress[milestone].open++;
                }
              }
            }

            // Generate progress report
            let progressReport = '# üìä Project Progress Report\n\n';
            progressReport += `Generated on: ${new Date().toISOString().split('T')[0]}\n\n`;

            for (const [milestone, progress] of Object.entries(milestoneProgress)) {
              const percentage = Math.round((progress.closed / progress.total) * 100);
              progressReport += `## ${milestone}\n`;
              progressReport += `- Progress: ${progress.closed}/${progress.total} (${percentage}%)\n`;
              progressReport += `- Open: ${progress.open}\n`;
              progressReport += `- Closed: ${progress.closed}\n\n`;
            }

            // Create or update progress issue
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'progress-report',
              state: 'open'
            });

            if (existingIssues.data.length > 0) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssues.data[0].number,
                body: progressReport
              });
            } else {
              // Create new progress report issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üìä Weekly Progress Report - ${new Date().toISOString().split('T')[0]}`,
                body: progressReport,
                labels: ['progress-report', 'automated', 'pinned']
              });
            }

  milestone-management:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Manage milestones
        uses: actions/github-script@v7
        with:
          script: |
            const now = new Date();
            const milestones = await github.rest.issues.listMilestones({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            for (const milestone of milestones.data) {
              const dueDate = new Date(milestone.due_on);
              const daysUntilDue = Math.ceil((dueDate - now) / (1000 * 60 * 60 * 24));
              
              // Warn about approaching deadlines
              if (daysUntilDue <= 7 && daysUntilDue > 0) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `‚ö†Ô∏è Milestone "${milestone.title}" due in ${daysUntilDue} days`,
                  body: `The milestone **${milestone.title}** is due on ${milestone.due_on}.
                  
                  **Progress**: ${milestone.closed_issues}/${milestone.closed_issues + milestone.open_issues} issues completed
                  **Remaining**: ${milestone.open_issues} open issues
                  
                  Please review the remaining issues and consider:
                  - Moving non-critical issues to the next milestone
                  - Prioritizing critical issues
                  - Requesting additional help if needed
                  
                  [View Milestone](${milestone.html_url})`,
                  labels: ['milestone-warning', 'automated']
                });
              }
              
              // Auto-close overdue milestones with no open issues
              if (daysUntilDue < 0 && milestone.open_issues === 0) {
                await github.rest.issues.updateMilestone({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  milestone_number: milestone.number,
                  state: 'closed'
                });
                
                console.log(`Closed completed milestone: ${milestone.title}`);
              }
            }

  issue-metrics:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Calculate issue metrics
        uses: actions/github-script@v7
        with:
          script: |
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

            // Get recent issues
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              since: thirtyDaysAgo.toISOString(),
              per_page: 100
            });

            let metrics = {
              totalIssues: 0,
              openIssues: 0,
              closedIssues: 0,
              avgTimeToClose: 0,
              bugReports: 0,
              featureRequests: 0,
              templateRequests: 0,
              versionUpdates: 0
            };

            let totalCloseTime = 0;
            let closedCount = 0;

            for (const issue of issues.data) {
              if (issue.pull_request) continue; // Skip PRs
              
              metrics.totalIssues++;
              
              if (issue.state === 'open') {
                metrics.openIssues++;
              } else {
                metrics.closedIssues++;
                
                // Calculate time to close
                const created = new Date(issue.created_at);
                const closed = new Date(issue.closed_at);
                const timeToClose = (closed - created) / (1000 * 60 * 60 * 24); // days
                
                totalCloseTime += timeToClose;
                closedCount++;
              }
              
              // Categorize by labels
              const labels = issue.labels.map(label => 
                typeof label === 'string' ? label : label.name
              );
              
              if (labels.includes('bug')) metrics.bugReports++;
              if (labels.includes('enhancement')) metrics.featureRequests++;
              if (labels.includes('template')) metrics.templateRequests++;
              if (labels.includes('version-update')) metrics.versionUpdates++;
            }

            if (closedCount > 0) {
              metrics.avgTimeToClose = Math.round(totalCloseTime / closedCount * 10) / 10;
            }

            // Create metrics report
            const metricsReport = `# üìà Issue Metrics (Last 30 Days)

            ## Summary
            - **Total Issues**: ${metrics.totalIssues}
            - **Open Issues**: ${metrics.openIssues}
            - **Closed Issues**: ${metrics.closedIssues}
            - **Average Time to Close**: ${metrics.avgTimeToClose} days

            ## Issue Types
            - **Bug Reports**: ${metrics.bugReports}
            - **Feature Requests**: ${metrics.featureRequests}
            - **Template Requests**: ${metrics.templateRequests}
            - **Version Updates**: ${metrics.versionUpdates}

            ## Health Indicators
            - **Resolution Rate**: ${Math.round((metrics.closedIssues / metrics.totalIssues) * 100)}%
            - **Response Time**: ${metrics.avgTimeToClose < 7 ? '‚úÖ Good' : '‚ö†Ô∏è Needs Improvement'}
            - **Issue Velocity**: ${Math.round(metrics.totalIssues / 30 * 10) / 10} issues/day

            Generated on: ${new Date().toISOString()}`;

            console.log(metricsReport);

            // You could also create an issue with these metrics or send to external service

  pr-management:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Manage PR lifecycle
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;

            if (context.payload.action === 'ready_for_review') {
              // Add to review queue
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['needs-review']
              });
              
              // Estimate review complexity
              const additions = pr.additions;
              const deletions = pr.deletions;
              const changedFiles = pr.changed_files;
              
              let complexity = 'low';
              if (additions > 500 || changedFiles > 10) {
                complexity = 'high';
              } else if (additions > 100 || changedFiles > 5) {
                complexity = 'medium';
              }
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: [`review-complexity:${complexity}`]
              });
            }

            if (context.payload.action === 'closed' && pr.merged) {
              // Thank contributor and gather metrics
              const timeToMerge = (new Date(pr.merged_at) - new Date(pr.created_at)) / (1000 * 60 * 60 * 24);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `üéâ **PR Merged Successfully!**
                
                Thank you @${pr.user.login} for your contribution!
                
                **Stats:**
                - Time to merge: ${Math.round(timeToMerge * 10) / 10} days
                - Changes: +${pr.additions} -${pr.deletions}
                - Files: ${pr.changed_files}
                
                Your changes will be included in the next release. üöÄ`
              });
            }
